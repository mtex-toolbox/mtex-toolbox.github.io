---
title: Density Estimation
last_updated: 15-Nov-2020
sidebar: documentation_sidebar
permalink: DensityEstimation.html
folder: documentation
toc: false
---
    <html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Density Estimation</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-11-15"><meta name="DC.source" content="script_DensityEstimation.m"></head><body><font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/GeneralConcepts/DensityEstimation.m">
    edit page</a></font><div><!--introduction--><!--/introduction--><p>Density estimation is a concept to estimate a probability density function \(f_N\) from given random samples \(x_n\), \(n=1,\ldots,N\). In the simplest case the random samples \(x_n\) are real numbers and come from an unknown distribution function \(f\). The goal is than that \(f_N\) approximates \(f\) as best as possible.</p><p>Lets illustrate this setting at a the example of a mixed Gaussian distribution</p>
{% highlight matlab %}
% the true density function
f = @(x) Gaussian(0.2,0.05,x) + Gaussian(0.5,0.2,x);

% plot the true density function
x = linspace(0,1,1000);
plot(x,f(x),'linewidth',2)

% a random sample
N = 20;
xN = discreteSample(f,N,'range',[0,1]);

% plot the random sample
hold on
plot(xN,zeros(size(xN)),'o','LineWidth',2,'MarkerEdgeColor','r')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_01.png" %}
</center><h2 id="2">The Histogram</h2><p>The easiest way to estimate a density function from the samples \(x_n\) is a histogram</p>
{% highlight matlab %}
histogram(xN,10)
hold on
plot(x,f(x),'linewidth',2)
plot(xN,zeros(size(xN)),'o','LineWidth',2,'MarkerEdgeColor','r')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_02.png" %}
</center><p>However, since the histogram allways leads to a picewice constant function the fit to the true density function \(f\) is usually not so good. A better alternative is kernel density estimation.</p><h2 id="4">Kernel Density Estimation</h2><p>The idea of kernel density estimation is to fix some kernel function \(\psi\), e.g. a Gaussian with mean \(0\) and stadard deviation \(0.05\),</p>
{% highlight matlab %}
psi = Gaussian(0,0.05);
{% endhighlight %}
<p>shift its center to the position of each sample points \(x_n\)</p>
{% highlight matlab %}
% plot the random sample
plot(xN,zeros(size(xN)),'o','LineWidth',2,'MarkerEdgeColor','r')
hold on

% for each random sample plot a centered Gaussian
for n = 1:N, plot(x,psi(x-xN(n)),'k'); end
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_03.png" %}
</center><p>and take the mean</p><p>\[ f(x) = \frac{1}{N} \sum_{n=1}^N \psi(x-x_n) \]</p><p>of all the these shifted kernel functions</p>
{% highlight matlab %}
% take the mean over all shifted kernel functions
fN = @(x) mean(psi(x-xN),1);

hold on
% plot the resulting function
plot(x,fN(x),'linewidth',2)

% plot the "true" density function
plot(x,f(x),'linewidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_04.png" %}
</center><p>We observe that this gives a much better approximation to true density function \(f\). The most important parameter when computing the kernel density estimate of a random sample is the halfwidth or standard deviation of the corresponding kernel function. Lets repeat the above density estimation with three different standard deviations</p>
{% highlight matlab %}
% plot the true density function
plot(x,f(x),'linewidth',2)
hold on

% and on top the kernel density estimates with different halfwidth
delta = [0.01 0.05 0.25];
for d = delta

  psi = Gaussian(0,d);
  fN = @(x) mean(psi(x-xN),1);
  plot(x,fN(x),'linewidth',2)

end
hold off
legend('\(f\)','\(f_{0.01}\)','\(f_{0.05}\)','\(f_{0.25}\)','interpreter','Latex'),
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_05.png" %}
</center><p>In general a too small halfwidth leads to heavily oscillating functions, while a to large halfwdith will result in too smooth functions. In the case of one dimensional data the optimal half width is determined automatically when using the command <a href="calcDensity.html"><code class="language-plaintext highlighter-rouge">calcDensity</code></a>.</p>
{% highlight matlab %}
fN = calcDensity(xN,'range',[0;1]);

% we may control the halfwidth by the option 'bandwidth'
%fN = calcDensity(xN,'range',[0;1],'bandwidth',0.004);

plot(x,f(x),'linewidth',2)
hold on
plot(x,fN(x),'linewidth',2)
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_06.png" %}
</center><h2 id="9">Optimal Halfwidth Selection</h2><p>Selecting an optimal kernel halfwidth is a tough problem. MTEX provides a couple of methods for this purpose which are explained in detail in the section <a href="OptimalKernel.html">Optimal Kernel Selection</a>.</p><h2 id="10">Kernel Density Estimation in d-Dimensions</h2><p>The command <a href="calcDensity.html">calcDensity</a> may also be applied to \(d\)-dimenional data. For simplicity lets consider a two dimensional example where both \(x\) and \(y\) coordinates are distributed according to the distribution \(f\) defined at the very beginning of this section.</p>
{% highlight matlab %}
% the number of sample points
N = 100;
xN = discreteSample(f,N);
yN = discreteSample(f,N);

% plot the random sample
scatter(xN,yN)
axis equal tight
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_07.png" %}
</center><p>Similarly to the one dimensional example we need to specify the range of the \(x\) and \(y\) coordinates for the estimated density function. The format is <code class="language-plaintext highlighter-rouge">[xMin yMin; xMax yMax]</code>.</p>
{% highlight matlab %}
% compte the two dimensional density function
fN = calcDensity([xN,yN],'range',[0 0;1 1]);

% plot the two dimensional density function
[x,y] = ndgrid(linspace(0,1));
contourf(x,y,fN(x,y),'LevelStep',2)
mtexColorMap LaboTeX
shading interp
axis equal tight

% plot the original random sample on top
hold on
scatter(xN,yN,'.','k')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_08.png" %}
</center><h2 id="12">Density Estimation for Directional Data</h2><p>Kernel density for directional data works analogously as for real valued data. Again we have to choose a kernel function \(\psi\) with a certain halfwidth \(\delta\). Than the kernel functions are centered at each direction of our random sampling and summed up. Lets us demonstrate this procedure misorientation axes between two phases in an EBSD map</p>
{% highlight matlab %}
% import ebsd data
mtexdata forsterite silent

% reconstruct grains
grains = calcGrains(ebsd('indexed'));

% extract Forsterite to Enstatite grain boundaries
gB = grains.boundary('Forsterite','Enstatite');

% plot misorientation axes
plot(gB.misorientation.axis,'fundamentalRegion','MarkerFaceAlpha',0.1)
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_09.png" %}
</center><p>The distribution of the misorientation axes may be analyzed in more detail by computing the misorientation axis distribution function</p>
{% highlight matlab %}
% compute the misorientation axis distribution function
axisDensity = calcDensity(gB.misorientation.axis);

% plot the density function
contourf(axisDensity)
mtexColorMap LaboTeX
mtexColorbar

% and on top of it the misorientation axes
hold on
plot(gB.misorientation.axis,'MarkerEdgeAlpha',0.05,'MarkerFaceColor','none','MarkerEdgeColor','k')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_10.png" %}
</center><p>Note that the resulting variable <code class="language-plaintext highlighter-rouge">axisDensity</code> is of type <a href="S2FunHarmonicSym.S2FunHarmonicSym.html">S2FunHarmonicSym</a> and allows for all the operations as explained in the section <a href="S2FunOperations.html">Operations on Spherical Functions</a>. In order to stress once again the importance of the choice of the halfwidth of the kernel function we perform the same calculation as above but with the halfwidth set to 5 degree</p>
{% highlight matlab %}
axisDensity = calcDensity(gB.misorientation.axis,'halfwidth',5*degree);

contourf(axisDensity)
mtexColorMap LaboTeX
mtexColorbar

hold on
plot(gB.misorientation.axis,'MarkerEdgeAlpha',0.05,'MarkerFaceColor','none','MarkerEdgeColor','k')
hold off
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_11.png" %}
</center><h2 id="15">Density Estimation for Orientation Data</h2><p>Density estimation from orientations sets the connection between individal crystal orientations, as e.g. measured by EBSD, and the orientation distribution function of a specimen. Considering the Forsterite orientations from the above EBSD map the corresponding ODF computes to</p>
{% highlight matlab %}
odf = calcDensity(ebsd('Forsterite').orientations,'halfwidth',10*degree)
{% endhighlight %}

{% highlight plaintext %}
odf = ODF  
  crystal symmetry : Forsterite (mmm)
  specimen symmetry: 1
 
  Harmonic portion:
    degree: 25
    weight: 1
{% endhighlight %}
<p>Lets visualize the ODF in phi2 sections and plot on top of it the individual orientation measurements from the EBSD map</p>
{% highlight matlab %}
plotSection(odf,'contourf')
mtexColorMap LaboTeX

hold on
plot(ebsd('Forsterite').orientations,'MarkerEdgeAlpha',0.05,...
  'MarkerFaceColor','none','MarkerEdgeColor','k','MarkerSize',10)
hold off
{% endhighlight %}

{% highlight plaintext %}
plotting 2000 random orientations out of 152345 given orientations
{% endhighlight %}
<center>
{% include inline_image.html file="DensityEstimation_12.png" %}
</center><p>A more detailed describtion of ODF estimation from individual orientation measurements can be found in the section <a href="EBSD2ODF.html">ODF Estimation from EBSD data</a>.</p><h2 id="18">Parametric Density Estimation</h2><p>In contrast to kernel density estimation parametric density estimation makes the assumption that the true distribution function belong to a parametric distribution family, e.g. the Gaussian. In this case it remains the estimate the parameters of this distribution from the random sample. In the case of the Gaussian distribution these are the mean value and the standard deviation. The analogous to the Gaussian on the sphere and the orientation space are the Bingham distributions. The estimation of Bingham parameters from directional and rotational data are explained in the sections <a href="S2FunBingham.html">The Spherical Bingham Distribution</a> and <a href="BinghamODFs.html">The Rotational Bingham Distribution</a>.</p><h2 id="19">Density Estimtation with Weights</h2><p>In many use cases one has a weighted random sample. A typical example is if one wants to estimate a orientation distribution function from grain orientations. In this cases big grains should contribute more to the ODF than small grains. For that reason the functions <code class="language-plaintext highlighter-rouge">calcDensity</code> allow for an additional option <code class="language-plaintext highlighter-rouge">'weights'</code> which allows to pass weights to the density estimation.</p>
{% highlight matlab %}
mtexdata titanium silent
grains = calcGrains(ebsd);

odf = calcDensity(grains.meanOrientation,'weights',grains.grainSize)
{% endhighlight %}

{% highlight plaintext %}
odf = ODF  
  crystal symmetry : Titanium (Alpha) (622, X||a, Y||b*, Z||c)
  specimen symmetry: 1
 
  Radially symmetric portion:
    kernel: de la Vallee Poussin, halfwidth 10Â°
    center: Rotations: 85 x 1
    weight: 1
{% endhighlight %}
</div></body></html>