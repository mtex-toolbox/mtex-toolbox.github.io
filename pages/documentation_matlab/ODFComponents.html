---
title: ODF Component Analysis

sidebar: documentation_sidebar
permalink: ODFComponents.html
folder: documentation
toc: false
---
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
    -->
<title>ODF Component Analysis</title>
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.source" content="script_ODFComponents.m">
</head>
<body>
<font size="2"><a href="https://github.com/mtex-toolbox/mtex/blob/develop/doc/ODFAnalysis/ODFComponents.m">
    edit page</a></font>
<div>
<!--introduction-->
<!--/introduction-->
<p>A common way to interpret ODFs is to think of them as superposition of different components that originate from different deformation processes and describe the texture of the material. In this section we describe how these components can be identified from a given ODF.</p>
<p>We start by reconstruction a Quartz ODF from Neutron pole figure data.</p>
{% highlight matlab %}
% import Neutron pole figure data from a Quartz specimen
mtexdata dubna silent

% reconstruct the ODF
odf = calcODF(pf,'zeroRange');

% visualize the ODF in sigma sections
plotSection(odf,'sigma','sections',12,'layout',[3,4])
mtexColorbar
{% endhighlight %}
<center>
{% include inline_image.html file="ODFComponents_01.png" %}
</center>
<h2 id="2">The preferred orientation</h2>
<p>First of all we observe that the ODF posses a strong maximum. To find this orientation that corresponds to the maximum ODF intensity we use the <a href="SO3Fun.max.html"><code class="language-plaintext highlighter-rouge">max</code></a> command.</p>
{% highlight matlab %}
[value,ori] = max(odf)
{% endhighlight %}

{% highlight plaintext %}
value =
  106.1526
 
ori = orientation (Quartz → y↑→x)
 
  Bunge Euler angles in degree
     phi1     Phi    phi2
  133.047 34.5158  207.16
{% endhighlight %}
<p>Note that, similarly as the MATLAB <a href="https://de.mathworks.com/help/matlab/ref/max.html"><code class="language-plaintext highlighter-rouge">max</code></a> command, the second output argument is the position where the maximum is attained. In our case we observe that the maximum value is about <code class="language-plaintext highlighter-rouge">121</code>. To visualize the corresponding preferred orientation we plot it into the sigma sections of the ODF.</p>
{% highlight matlab %}
annotate(ori)
{% endhighlight %}
<center>
{% include inline_image.html file="ODFComponents_02.png" %}
</center>
<p>We may not only use the command <a href="SO3Fun.max.html"><code class="language-plaintext highlighter-rouge">max</code></a> to find the global maximum of an ODF but also to find a certain amount of local maxima. The number of local maxima MTEX should search for, is specified as by the option <code class="language-plaintext highlighter-rouge">'numLocal'</code>, i.e., to find the three largest local maxima do</p>
{% highlight matlab %}
[value,ori] = max(odf,'numLocal',3)

annotate(ori(2:end),'MarkerFaceColor','red')
{% endhighlight %}

{% highlight plaintext %}
value =
  106.1526
   39.5028
   21.8787
 
ori = orientation (Quartz → y↑→x)
  size: 3 x 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2
  133.047 34.5158  207.16
  136.129 36.5776 263.088
  89.1225 32.0272 328.032
{% endhighlight %}
<center>
{% include inline_image.html file="ODFComponents_03.png" %}
</center>
<p>Note, that orientations are returned sorted according to their ODF value.</p>
<h2 id="6">Volume Portions</h2>
<p>It is important to understand, that the value of the ODF at a preferred orientation is in general not sufficient to judge the importance of a component. Very sharp components may result in extremely large ODF values that represent only very little volume. A more robust and physically more relevant quantity is the relative volume of crystal that have an orientation close to the preferred orientation. This volume portion can be computed by the command <a href="SO3Fun.volume.html,"><code class="language-plaintext highlighter-rouge">volume(odf,ori,delta)</code></a> where <code class="language-plaintext highlighter-rouge">ori</code> is a list of preferred orientations and <code class="language-plaintext highlighter-rouge">delta</code> is the maximum disorientation angle. Multiplying with \(100\) the output will be in percent</p>
{% highlight matlab %}
delta = 10*degree;
volume(odf,ori,delta) * 100
{% endhighlight %}

{% highlight plaintext %}
ans =
   10.0162
    4.2756
    2.3085
{% endhighlight %}
<p>We observe that the sum of all volume portions is far from \(100\) percent. This is very typical. The reason is that the portion of the full orientations space that is within the \(10\) degree disorientation distance from the preferred orientations is very small. More precisely, it represents only</p>
{% highlight matlab %}
volume(uniformODF(odf.CS),ori(1),delta) * 100
{% endhighlight %}

{% highlight plaintext %}
ans =
    0.1690
{% endhighlight %}
<p>percent of the entire orientations space. Putting these values in relation it becomes clear, that all the components are multiple times stronger than the uniform distribution. We may compute these factors by</p>
{% highlight matlab %}
volume(odf,ori,delta) ./ volume(uniformODF(odf.CS),ori,delta)
{% endhighlight %}

{% highlight plaintext %}
ans =
   59.2762
   25.3030
   13.6616
{% endhighlight %}
<p>It is important to understand, that all these values above depend significantly from the chosen disorientation angle <code class="language-plaintext highlighter-rouge">delta</code>. If <code class="language-plaintext highlighter-rouge">delta</code> is chosen too large</p>
{% highlight matlab %}
delta = 40*degree
volume(odf,ori,delta)*100
{% endhighlight %}

{% highlight plaintext %}
delta =
    0.6981
ans =
   42.9599
   32.5091
   34.2095
{% endhighlight %}
<p>it may even happen that the components overlap and the sum of the volumes exceeds 100 percent.</p>
<h2 id="11">Non circular components</h2>
<p>A disadvantage of the approach above is that one is restricted to circular components with a fixed disorientation angle which makes it hard to analyze components that are close together. In such settings one may want to use the command <a href="SO3Fun.calcComponents.html"><code class="language-plaintext highlighter-rouge">calcComponents</code></a>. This command starts with evenly distributed orientations and lets the crawl towards the closest preferred orientation. At the end of this process the command returns these preferred orientation and the percentage of orientations that crawled to each of them.</p>
{% highlight matlab %}
[ori, vol] = calcComponents(odf);
ori
vol * 100
{% endhighlight %}

{% highlight plaintext %}
ori = orientation (Quartz → y↑→x)
  size: 13 x 1
 
  Bunge Euler angles in degree
     phi1     Phi    phi2
  132.898 34.4654 207.245
   136.09 36.5906 263.167
  76.0005 31.2479 280.393
  89.7483    31.7 208.055
  27.9842  49.058 291.758
  257.145 32.7075 95.9347
  304.084 63.7077 39.0428
   231.35  58.236 130.307
  348.788 30.9359 326.838
  273.018 61.0376 18.0205
  237.018 66.3019 66.2121
  91.3824 32.1173 208.862
  352.425 31.4184 326.841
 
ans =
   36.7302
   21.6220
    8.6210
    6.4254
    3.5524
    2.8876
    2.4003
    2.2447
    1.9547
    1.4056
    1.2158
    1.0931
    1.0024
{% endhighlight %}
<p>These volumes always sums up to approximately 100 percent. While the preferred orientations should be the same as those computed by the <code class="language-plaintext highlighter-rouge">max</code> command.</p>
{% highlight matlab %}
annotate(ori,'MarkerFaceColor','none','MarkerEdgeColor','white',...
  'linewidth',2,'MarkerSize',15,'marker','o')
{% endhighlight %}
<center>
{% include inline_image.html file="ODFComponents_04.png" %}
</center>
</div>
</body>
</html>
